{
  "last_updated": "2025-11-30T21:39:35.962785+00:00",
  "count": 20,
  "articles": [
    {
      "id": "48e81a0447d7157d50ba6230f4dd38ff",
      "url": "https://www.frontiersin.org/articles/10.3389/fncom.2025.1692418",
      "title": "Interleaving cortex-analog mixing improves deep non-negative matrix factorization networks",
      "content": "Considering biological constraints in artificial neural networks has led to dramatic improvements in performance. Nevertheless, to date, the positivity of long-range signals in the cortex has not been shown to yield improvements. While Non-negative matrix factorization (NMF) captures biological constraints of positive long-range interactions, deep convolutional neural networks with NMF modules do not match the performance of conventional neural networks (CNNs) of a similar size. This work shows that introducing intermediate modules that combine the NMF's positive activities, analogous to the processing in cortical columns, leads to improved performance on benchmark data that exceeds that of vanilla deep convolutional networks. This demonstrates that including positive long-range signaling together with local interactions of both signs in analogy to cortical hyper-columns has the potential to enhance the performance of deep networks.",
      "author": "Klaus R. Pawelzik",
      "published_date": "2025-11-05T00:00:00+00:00",
      "source": "Frontiers Computational Neuroscience",
      "status": "pending",
      "priority": "medium",
      "tags": [],
      "word_count": 129,
      "reading_time": 1,
      "created_at": "2025-11-30T21:38:54.471920+00:00",
      "updated_at": "2025-11-30T21:38:54.471921+00:00"
    },
    {
      "id": "f04f02121b1d13836df0a2b01a861136",
      "url": "https://www.frontiersin.org/articles/10.3389/fnbot.2025.1681341",
      "title": "UAV-based intelligent traffic surveillance using recurrent neural networks and Swin transformer for dynamic environments",
      "content": "IntroductionUrban traffic congestion, environmental degradation, and road safety challenges necessitate intelligent aerial robotic systems capable of real-time adaptive decision-making. Unmanned Aerial Vehicles (UAVs), with their flexible deployment and high vantage point, offer a promising solution for large-scale traffic surveillance in complex urban environments. This study introduces a UAV-based neural framework that addresses challenges such as asymmetric vehicle motion, scale variations, and spatial inconsistencies in aerial imagery.MethodsThe proposed system integrates a multi-stage pipeline encompassing contrast enhancement and region-based clustering to optimize segmentation while maintaining computational efficiency for resource-constrained UAV platforms. Vehicle detection is carried out using a Recurrent Neural Network (RNN), optimized via a hybrid loss function combining cross-entropy and mean squared error to improve localization and confidence estimation. Upon detection, the system branches into two neural submodules: (i) a classification stream utilizing SURF and BRISK descriptors integrated with a Swin Transformer backbone for precise vehicle categorization, and (ii) a multi-object tracking stream employing DeepSORT, which fuses motion and appearance features within an affinity matrix for robust trajectory association.ResultsComprehensive evaluation on three benchmark UAV datasets\u2014AU-AIR, UAVDT, and VAID shows consistent and high performance. The model achieved detection precisions of 0.913, 0.930, and 0.920; tracking precisions of 0.901, 0.881, and 0.890; and classification accuracies of 92.14, 92.75, and 91.25%, respectively.DiscussionThese findings highlight the adaptability, robustness, and real-time viability of the proposed architecture in aerial traffic surveillance applications. By effectively integrating detection, classification, and tracking within a unified neural framework, the system contributes significant advancements to intelligent UAV-based traffic monitoring and supports future developments in smart city mobility and decision-making systems.",
      "author": "Hui Liu",
      "published_date": "2025-10-13T00:00:00+00:00",
      "source": "Frontiers Neurorobotics",
      "status": "pending",
      "priority": "medium",
      "tags": [],
      "word_count": 258,
      "reading_time": 1,
      "created_at": "2025-11-30T21:38:51.193993+00:00",
      "updated_at": "2025-11-30T21:38:51.193994+00:00"
    },
    {
      "id": "af9955da13697cdc0dba672afc9d5610",
      "url": "https://twitter.com/hkashfi/status/1995109785679573167",
      "title": "\"Boobs check\" verify if sites behind CDN are hosted in Inside Iran or not",
      "content": "<p>Article URL: <a href=\"https://twitter.com/hkashfi/status/1995109785679573167\">https://twitter.com/hkashfi/status/1995109785679573167</a></p>\n<p>Comments URL: <a href=\"https://news.ycombinator.com/item?id=46100323\">https://news.ycombinator.com/item?id=46100323</a></p>\n<p>Points: 11</p>\n<p># Comments: 0</p>",
      "author": "defly",
      "published_date": "2025-11-30T20:54:43+00:00",
      "source": "Hacker News",
      "status": "pending",
      "priority": "medium",
      "tags": [],
      "word_count": 13,
      "reading_time": 1,
      "created_at": "2025-11-30T21:38:23.616646+00:00",
      "updated_at": "2025-11-30T21:38:23.616654+00:00"
    },
    {
      "id": "012bd9b801fc3041e84ec9b533fbd0a7",
      "url": "https://nasa.cx/hn/posts/how-to-run-hundreds-of-phones-while-being-struck-by-suicide-drones/",
      "title": "How to run phones while being struck by suicide drones",
      "content": "<a href=\"https://news.ycombinator.com/item?id=46100282\">Comments</a>",
      "author": "",
      "published_date": "2025-11-30T20:49:49+00:00",
      "source": "Hacker News",
      "status": "pending",
      "priority": "medium",
      "tags": [],
      "word_count": 2,
      "reading_time": 1,
      "created_at": "2025-11-30T21:18:18.172471+00:00",
      "updated_at": "2025-11-30T21:18:18.172473+00:00"
    },
    {
      "id": "a67d759fe083e87bf31611c09d3e7e05",
      "url": "https://www.zdnet.com/article/why-people-keep-flocking-to-linux-in-2025-and-its-not-just-to-escape-windows/",
      "title": "By my count, Linux has 11% of the desktop market. Here's how I got that number",
      "content": "<p>Article URL: <a href=\"https://www.zdnet.com/article/why-people-keep-flocking-to-linux-in-2025-and-its-not-just-to-escape-windows/\">https://www.zdnet.com/article/why-people-keep-flocking-to-linux-in-2025-and-its-not-just-to-escape-windows/</a></p>\n<p>Comments URL: <a href=\"https://news.ycombinator.com/item?id=46099985\">https://news.ycombinator.com/item?id=46099985</a></p>\n<p>Points: 15</p>\n<p># Comments: 2</p>",
      "author": "breve",
      "published_date": "2025-11-30T20:14:12+00:00",
      "source": "Hacker News",
      "status": "pending",
      "priority": "medium",
      "tags": [],
      "word_count": 13,
      "reading_time": 1,
      "created_at": "2025-11-30T21:18:16.789767+00:00",
      "updated_at": "2025-11-30T21:18:16.789769+00:00"
    },
    {
      "id": "012bd9b801fc3041e84ec9b533fbd0a7",
      "url": "https://nasa.cx/hn/posts/how-to-run-hundreds-of-phones-while-being-struck-by-suicide-drones/",
      "title": "How to run phones while being struck by suicide drones",
      "content": "<p>Article URL: <a href=\"https://nasa.cx/hn/posts/how-to-run-hundreds-of-phones-while-being-struck-by-suicide-drones/\">https://nasa.cx/hn/posts/how-to-run-hundreds-of-phones-while-being-struck-by-suicide-drones/</a></p>\n<p>Comments URL: <a href=\"https://news.ycombinator.com/item?id=46100282\">https://news.ycombinator.com/item?id=46100282</a></p>\n<p>Points: 26</p>\n<p># Comments: 7</p>",
      "author": "nasaok",
      "published_date": "2025-11-30T20:49:49+00:00",
      "source": "Hacker News",
      "status": "pending",
      "priority": "medium",
      "tags": [],
      "word_count": 13,
      "reading_time": 1,
      "created_at": "2025-11-30T21:18:16.789731+00:00",
      "updated_at": "2025-11-30T21:18:16.789743+00:00"
    },
    {
      "id": "3d414254a2ee76b578451f154d9f0a4a",
      "url": "https://www.potaroo.net/ispcol/2025-11/starlinkgeo2.html",
      "title": "A Second Look at Geolocation and Starlink",
      "content": "<a href=\"https://news.ycombinator.com/item?id=46047562\">Comments</a>",
      "author": "",
      "published_date": "2025-11-25T16:37:31+00:00",
      "source": "Hacker News",
      "status": "pending",
      "priority": "medium",
      "tags": [],
      "word_count": 2,
      "reading_time": 1,
      "created_at": "2025-11-30T20:41:39.015472+00:00",
      "updated_at": "2025-11-30T20:41:39.015473+00:00"
    },
    {
      "id": "64a7804696cc066ca55b756a545eb814",
      "url": "https://www.biorxiv.org/content/10.1101/2025.11.26.690143v1?rss=1",
      "title": "U7 small nuclear RNA splice-switching therapeutics for STMN2 and UNC13A in Amyotrophic Lateral Sclerosis",
      "content": "TDP-43 nuclear depletion in amyotrophic lateral sclerosis (ALS) causes de-repression of cryptic exons (CEs) in multiple transcripts, including UNC13A and STMN2, disrupting synaptic transmission and neurite outgrowth. We developed a therapeutic U7 snRNA (tU7) approach that suppresses TDP-43-dependent mis-splicing, restores target gene expression, rescues neuronal functions in human iPSC-derived neurons, and shows target engagement in vivo, positioning tU7-mediated splicing correction as a promising therapeutic strategy for ALS.",
      "author": "Mehta, P. R., Solomon, T., Pickles, S., Harley, P., Barioglio, M., Schweingruber, C., Marrero-Gagliardi, A., Gao, Y., Mattedi, F., Barattucci, S., Lin, L. T.-W., Ryadnov, E., Zanovello, M., Cammack, A. J., Isaacs, A., Burrone, J., Shaw, C. E., Keuss, M. J., Petrucelli, L., Fratta, P., Ruepp, M.-D.",
      "published_date": "2025-11-30T00:00:00+00:00",
      "source": "Biorxiv Neuroscience",
      "status": "pending",
      "priority": "medium",
      "tags": [],
      "word_count": 67,
      "reading_time": 1,
      "created_at": "2025-11-30T20:23:07.151553+00:00",
      "updated_at": "2025-11-30T20:23:07.151557+00:00"
    },
    {
      "id": "5a0a7e6d9f642f480dd94c3be985f28e",
      "url": "https://arxiv.org/abs/2211.12588",
      "title": "Program-of-Thought Prompting Outperforms Chain-of-Thought by 15% (2022)",
      "content": "<a href=\"https://news.ycombinator.com/item?id=46099108\">Comments</a>",
      "author": "",
      "published_date": "2025-11-30T18:34:52+00:00",
      "source": "Hacker News",
      "status": "pending",
      "priority": "medium",
      "tags": [],
      "word_count": 2,
      "reading_time": 1,
      "created_at": "2025-11-30T20:22:25.726529+00:00",
      "updated_at": "2025-11-30T20:22:25.726531+00:00"
    },
    {
      "id": "9bd27ccf4c998161ffd521ec5bf2c6fc",
      "url": "https://www.humanlayer.dev/blog/writing-a-good-claude-md",
      "title": "Writing a Good Claude.md",
      "content": "<a href=\"https://news.ycombinator.com/item?id=46098838\">Comments</a>",
      "author": "",
      "published_date": "2025-11-30T17:56:43+00:00",
      "source": "Hacker News",
      "status": "pending",
      "priority": "medium",
      "tags": [],
      "word_count": 2,
      "reading_time": 1,
      "created_at": "2025-11-30T20:22:25.726510+00:00",
      "updated_at": "2025-11-30T20:22:25.726512+00:00"
    },
    {
      "id": "58a2f92e50082f6dedc5d4f2e6295280",
      "url": "https://www.docker.com/blog/do-you-really-need-microservices/",
      "title": "You Want Microservices, but Do You Need Them?",
      "content": "<a href=\"https://news.ycombinator.com/item?id=46099367\">Comments</a>",
      "author": "",
      "published_date": "2025-11-30T19:02:04+00:00",
      "source": "Hacker News",
      "status": "pending",
      "priority": "medium",
      "tags": [],
      "word_count": 2,
      "reading_time": 1,
      "created_at": "2025-11-30T20:22:25.726409+00:00",
      "updated_at": "2025-11-30T20:22:25.726411+00:00"
    },
    {
      "id": "9bd27ccf4c998161ffd521ec5bf2c6fc",
      "url": "https://www.humanlayer.dev/blog/writing-a-good-claude-md",
      "title": "Writing a Good Claude.md",
      "content": "<p>Article URL: <a href=\"https://www.humanlayer.dev/blog/writing-a-good-claude-md\">https://www.humanlayer.dev/blog/writing-a-good-claude-md</a></p>\n<p>Comments URL: <a href=\"https://news.ycombinator.com/item?id=46098838\">https://news.ycombinator.com/item?id=46098838</a></p>\n<p>Points: 24</p>\n<p># Comments: 0</p>",
      "author": "objcts",
      "published_date": "2025-11-30T17:56:43+00:00",
      "source": "Hacker News",
      "status": "pending",
      "priority": "medium",
      "tags": [],
      "word_count": 13,
      "reading_time": 1,
      "created_at": "2025-11-30T20:22:24.599776+00:00",
      "updated_at": "2025-11-30T20:22:24.599777+00:00"
    },
    {
      "id": "5a0a7e6d9f642f480dd94c3be985f28e",
      "url": "https://arxiv.org/abs/2211.12588",
      "title": "Program-of-Thought Prompting Outperforms Chain-of-Thought by 15% (2022)",
      "content": "<p>Article URL: <a href=\"https://arxiv.org/abs/2211.12588\">https://arxiv.org/abs/2211.12588</a></p>\n<p>Comments URL: <a href=\"https://news.ycombinator.com/item?id=46099108\">https://news.ycombinator.com/item?id=46099108</a></p>\n<p>Points: 15</p>\n<p># Comments: 4</p>",
      "author": "mkagenius",
      "published_date": "2025-11-30T18:34:52+00:00",
      "source": "Hacker News",
      "status": "pending",
      "priority": "medium",
      "tags": [],
      "word_count": 13,
      "reading_time": 1,
      "created_at": "2025-11-30T20:22:24.599696+00:00",
      "updated_at": "2025-11-30T20:22:24.599698+00:00"
    },
    {
      "id": "58a2f92e50082f6dedc5d4f2e6295280",
      "url": "https://www.docker.com/blog/do-you-really-need-microservices/",
      "title": "You Want Microservices, but Do You Need Them?",
      "content": "<p>Article URL: <a href=\"https://www.docker.com/blog/do-you-really-need-microservices/\">https://www.docker.com/blog/do-you-really-need-microservices/</a></p>\n<p>Comments URL: <a href=\"https://news.ycombinator.com/item?id=46099367\">https://news.ycombinator.com/item?id=46099367</a></p>\n<p>Points: 29</p>\n<p># Comments: 28</p>",
      "author": "tsenturk",
      "published_date": "2025-11-30T19:02:04+00:00",
      "source": "Hacker News",
      "status": "pending",
      "priority": "medium",
      "tags": [],
      "word_count": 13,
      "reading_time": 1,
      "created_at": "2025-11-30T20:22:24.599667+00:00",
      "updated_at": "2025-11-30T20:22:24.599675+00:00"
    },
    {
      "id": "d271f0f4d84a5d2a2670de456ace13b0",
      "url": "https://www.theguardian.com/books/2025/nov/30/does-laziness-start-in-the-brain-apathy-motivation",
      "title": "Does 'Laziness' Start in the Brain?",
      "content": "<p>Article URL: <a href=\"https://www.theguardian.com/books/2025/nov/30/does-laziness-start-in-the-brain-apathy-motivation\">https://www.theguardian.com/books/2025/nov/30/does-laziness-start-in-the-brain-apathy-motivation</a></p>\n<p>Comments URL: <a href=\"https://news.ycombinator.com/item?id=46098965\">https://news.ycombinator.com/item?id=46098965</a></p>\n<p>Points: 13</p>\n<p># Comments: 4</p>",
      "author": "billybuckwheat",
      "published_date": "2025-11-30T18:12:32+00:00",
      "source": "Hacker News",
      "status": "processed",
      "priority": "medium",
      "tags": [],
      "word_count": 13,
      "reading_time": 1,
      "created_at": "2025-11-30T19:37:46.287425+00:00",
      "updated_at": "2025-11-30T20:16:36.474515+00:00",
      "metadata": {
        "processed_at": "2025-11-30T20:16:36.474526+00:00",
        "processing_method": "github_actions"
      }
    },
    {
      "id": "6da481674970372be8bab2059f279508",
      "url": "https://www.reddit.com/r/mcp/s/dQoNo0fSx3",
      "title": "Garry Tan says MCP \"barely works\" today",
      "content": "<p>Article URL: <a href=\"https://www.reddit.com/r/mcp/s/dQoNo0fSx3\">https://www.reddit.com/r/mcp/s/dQoNo0fSx3</a></p>\n<p>Comments URL: <a href=\"https://news.ycombinator.com/item?id=46099222\">https://news.ycombinator.com/item?id=46099222</a></p>\n<p>Points: 9</p>\n<p># Comments: 1</p>",
      "author": "AbstractH24",
      "published_date": "2025-11-30T18:46:03+00:00",
      "source": "Hacker News",
      "status": "processed",
      "priority": "medium",
      "tags": [],
      "word_count": 13,
      "reading_time": 1,
      "created_at": "2025-11-30T19:37:46.287316+00:00",
      "updated_at": "2025-11-30T20:16:36.474530+00:00",
      "metadata": {
        "processed_at": "2025-11-30T20:16:36.474532+00:00",
        "processing_method": "github_actions"
      }
    },
    {
      "id": "17614835b8bf465b579a3623fc5e2168",
      "url": "https://www.reddit.com/r/Python/comments/1pamid8/contextasyncsqlalchemy_the_best_way_to_use/",
      "title": "context-async-sqlalchemy - The best way to use sqlalchemy in an async python application",
      "content": "<!-- SC_OFF --><div class=\"md\"><p>Hello! I\u2019d like to introduce my new library - <a href=\"https://github.com/krylosov-aa/context-async-sqlalchemy\"><strong>context-async-sqlalchemy</strong></a>. It makes working with <strong>SQLAlchemy</strong> in asynchronous Python applications incredibly easy. The library requires minimal code for simple use cases, yet offers maximum flexibility for more complex scenarios.</p> <p><strong>What My Project Does</strong>: greatly simplifies integrating sqlalchemy into an asynchronous Python application</p> <p><strong>Target Audience</strong>: Backend developers, use in production or hobby or anywhere</p> <p><strong>Comparison</strong>: There are no competitors with this approach. A couple of examples in the text below demonstrate why the library is superior. </p> <p>Let\u2019s briefly review the theory behind SQLAlchemy - what it consists of and how it integrates into a Python application. We\u2019ll explore some of the nuances and see how <a href=\"https://github.com/krylosov-aa/context-async-sqlalchemy\"><strong>context-async-sqlalchemy</strong></a> helps you work with it more conveniently. Note that everything here refers to <strong>asynchronous Python</strong>.</p> <h1>Short Summary of SQLAlchemy</h1> <p>SQLAlchemy provides an <strong>Engine</strong>, which manages the database connection pool, and a <strong>Session</strong>, through which SQL queries are executed. Each session uses a single connection that it obtains from the engine.</p> <p>The engine should have a long lifespan to keep the connection pool active. Sessions, on the other hand, should be short-lived, returning their connections to the pool as quickly as possible.</p> <h1>Integration and Usage in an Application</h1> <h1>Direct Usage</h1> <p>Let\u2019s start with the simplest manual approach - using only SQLAlchemy, which can be integrated anywhere.</p> <p>Create an engine and a session maker:</p> <pre><code>engine = create_async_engine(DATABASE_URL) session_maker = async_sessionmaker(engine, expire_on_commit=False) </code></pre> <p>Now imagine we have an endpoint for creating a user:</p> <pre><code>@app.post(&quot;/users/&quot;) async def create_user(name): async with session_maker() as session: async with session.begin(): await session.execute(stmt) </code></pre> <p>On line 2, we open a session; on line 3, we begin a transaction; and finally, on line 4, we execute some SQL to create a user.</p> <p>Now imagine that, as part of the user creation process, we need to execute two SQL queries:</p> <pre><code>@app.post(&quot;/users/&quot;) async def create_user(name): await insert_user(name) await insert_user_profile(name) async def insert_user(name): async with session_maker() as session: async with session.begin(): await session.execute(stmt) async def insert_user_profile(name): async with session_maker() as session: async with session.begin(): await session.execute(stmt) </code></pre> <p>Here we encounter two problems:</p> <ol> <li>Two transactions are being used, even though we probably want only one.</li> <li>Code duplication.</li> </ol> <p>We can try to fix this by moving the context managers to a higher level:</p> <pre><code>@app.post(&quot;/users/&quot;) async def create_user(name:): async with session_maker() as session: async with session.begin(): await insert_user(name, session) await insert_user_profile(name, session) async def insert_user(name, session): await session.execute(stmt) async def insert_user_profile(name, session): await session.execute(stmt) </code></pre> <p>But if we look at multiple handlers, the duplication still remains:</p> <pre><code>@app.post(&quot;/dogs/&quot;) async def create_dog(name): async with session_maker() as session: async with session.begin(): ... @app.post(&quot;/cats&quot;) async def create_cat(name): async with session_maker() as session: async with session.begin(): ... </code></pre> <h1>Dependency Injection</h1> <p>You can move session and transaction management into a dependency. For example, in <strong>FastAPI</strong>:</p> <pre><code>async def get_atomic_session(): async with session_maker() as session: async with session.begin(): yield session @app.post(&quot;/dogs/&quot;) async def create_dog(name, session = Depends(get_atomic_session)): await session.execute(stmt) @app.post(&quot;/cats/&quot;) async def create_cat(name, session = Depends(get_atomic_session)): await session.execute(stmt) </code></pre> <p>Code duplication is gone, but now the session and transaction remain open until the end of the request lifecycle, with no way to close them early and release the connection back to the pool.</p> <p>This could be solved by returning a DI container from the dependency that manages sessions - however, that approach adds complexity, and no ready\u2011made solutions exist.</p> <p>Additionally, the session now has to be passed through multiple layers of function calls, even to those that don\u2019t directly need it:</p> <pre><code>@app.post(&quot;/some_handler/&quot;) async def some_handler(session = Depends(get_atomic_session)): await do_first(session) await do_second(session) async def do_first(session): await do_something() await insert_to_database(session) async def insert_to_database(session): await session.execute(stmt) </code></pre> <p>As you can see, <code>do_first</code> doesn\u2019t directly use the session but still has to accept and pass it along. Personally, I find this inelegant - I prefer to encapsulate that logic inside <code>insert_to_database</code>. It\u2019s a matter of taste and philosophy.</p> <h1>Wrappers Around SQLAlchemy</h1> <p>There are various wrappers around SQLAlchemy that offer convenience but introduce new syntax - something I find undesirable. Developers already familiar with SQLAlchemy shouldn\u2019t have to learn an entirely new API.</p> <h1>The New Library</h1> <p>I wasn\u2019t satisfied with the existing approaches. In my FastAPI service, I didn\u2019t want to write excessive boilerplate just to work comfortably with SQL. I needed a minimal\u2011code solution that still allowed flexible session and transaction control - but couldn\u2019t find one. So I built it for myself, and now I\u2019m sharing it with the world.</p> <p><strong>My goals for the library were:</strong></p> <ul> <li>Minimal boilerplate and no code duplication</li> <li>Automatic commit or rollback when manual control isn\u2019t required</li> <li>The ability to manually manage sessions and transactions when needed</li> <li>Suitable for both simple CRUD operations and complex logic</li> <li>No new syntax - pure SQLAlchemy</li> <li>Framework\u2011agnostic design</li> </ul> <p>Here\u2019s the result.</p> <h1>Simplest Scenario</h1> <p>To make a single SQL query inside a handler - without worrying about sessions or transactions:</p> <pre><code>from context_async_sqlalchemy import db_session async def some_func() -&gt; None: session = await db_session(connection) # new session await session.execute(stmt) # some sql query # commit automatically </code></pre> <p>The <code>db_session</code> function automatically creates (or reuses) a session and closes it when the request ends.</p> <p>Multiple queries within one transaction:</p> <pre><code>@app.post(&quot;/users/&quot;) async def create_user(name): await insert_user(name) await insert_user_profile(name) async def insert_user(name): session = await db_session(connection) # creates a session await session.execute(stmt) # opens a connection and a transaction async def insert_user_profile(name): session = await db_session(connection) # gets the same session await session.execute(stmt) # uses the same connection and transaction </code></pre> <h1>Early Commit</h1> <p>Need to commit early? You can:</p> <pre><code>async def manual_commit_example(): session = await db_session(connect) await session.execute(stmt) await session.commit() # manually commit the transaction </code></pre> <p>Or, for example, consider the following scenario: you have a function called <code>insert_something</code> that\u2019s used in one handler where an autocommit at the end of the query is fine. Now you want to reuse <code>insert_something</code> in another handler that requires an early commit. You don\u2019t need to modify <code>insert_something</code> at all - you can simply do this:</p> <pre><code>async def example_1(): await insert_something() # autocommit is suitable for us here async def example_2(): await insert_something() # here we want to make a commit before the update await commit_db_session(connect) # commits the context transaction await update_something() # works with a new transaction </code></pre> <p>Or, even better, you can do it this way - by wrapping the function in a separate transaction:</p> <pre><code>async def example_2(): async with atomic_db_session(connect): # a transaction is opened and closed await insert_something() await update_something() # works with a new transaction </code></pre> <p>You can also perform an early rollback using <code>rollback_db_session</code>.</p> <h1>Early Session Close</h1> <p>There are situations where you may need to close a session to release its connection - for example, while performing other long\u2011running operations. You can do it like this:</p> <pre><code>async def example_with_long_work(): async with atomic_db_session(connect): await insert_something() await close_db_session(connect) # released the connection ... # some very long work here ... await update_something() </code></pre> <p><code>close_db_session</code> closes the current session. When <code>update_something</code> calls <code>db_session</code>, it will already have a new session with a different connection.</p> <h1>Concurrent Queries</h1> <p>In SQLAlchemy, you can\u2019t run two concurrent queries within the same session. To do so, you need to create a separate session.</p> <pre><code>async def concurent_example(): asyncio.gather( insert_something(some_args), insert_another_thing(some_args), # error! ) </code></pre> <p>The library provides two simple ways to execute concurrent queries.</p> <pre><code>async def concurent_example(): asyncio.gather( insert_something(some_args), run_in_new_ctx( # separate session with autocommit insert_another_thing, some_args ), ) </code></pre> <p><code>run_in_new_ctx</code> runs a function in a new context, giving it a fresh session. This can be used, for example, with functions executed via <code>asyncio.gather</code> or <code>asyncio.create_task</code>.</p> <p>Alternatively, you can work with a session entirely outside of any context - just like in the manual mode described at the beginning.</p> <pre><code>async def insert_another_thing(some_args): async with new_non_ctx_session(connection) as session: await session.execute(stmt) await session.commit() # or async def insert_something(some_args): async with new_non_ctx_atomic_session(connection) as session: await session.execute(stmt) </code></pre> <p>These methods can be combined:</p> <pre><code>await asyncio.gather( _insert(), # context session run_in_new_ctx(_insert), # new context session _insert_non_ctx(), # own manual session ) </code></pre> <h1>Other Scenarios</h1> <p>The repository includes several application integration examples. You can also explore <a href=\"https://github.com/krylosov-aa/context-async-sqlalchemy/tree/main/examples/fastapi_example/routes\">various scenarios for using the library</a>. These scenarios also serve as tests for the library - verifying its behavior within a real application context rather than in isolation.</p> <h1>Integrating the Library with Your Application</h1> <p>Now let\u2019s look at how to integrate this library into your application. The goal was to make the process as simple as possible.</p> <p>We\u2019ll start by creating the <code>engine</code> and <code>session_maker</code>, and by addressing the <code>connect</code> parameter, which is passed throughout the library functions. The <code>DBConnect</code> class is responsible for managing the database connection configuration.</p> <pre><code>from context_async_sqlalchemy import DBConnect connection = DBConnect( engine_creator=create_engine, session_maker_creator=create_session_maker, host=&quot;127.0.0.1&quot;, ) </code></pre> <p>The intended use is to have a global instance responsible for managing the lifecycle of the <code>engine</code> and <code>session_maker</code>.</p> <p>It takes two factory functions as input:</p> <ul> <li><code>engine_creator</code> - a factory function for creating the <code>engine</code></li> <li><code>session_maker_creator</code> - a factory function for creating the <code>session_maker</code></li> </ul> <p>Here are some examples:</p> <pre><code>def create_engine(host): pg_user = &quot;krylosov-aa&quot; pg_password = &quot;&quot; pg_port = 6432 pg_db = &quot;test&quot; return create_async_engine( f&quot;postgresql+asyncpg://&quot; f&quot;{pg_user}:{pg_password}&quot; f&quot;@{host}:{pg_port}&quot; f&quot;/{pg_db}&quot;, future=True, pool_pre_ping=True, ) def create_session_maker(engine): return async_sessionmaker( engine, class_=AsyncSession, expire_on_commit=False ) </code></pre> <p><code>host</code> is an optional parameter that specifies the database host to connect to.</p> <p>Why is the host optional, and why use factories? Because the library allows you to reconnect to the database at runtime - which is especially useful when working with a master and replica setup.</p> <p><code>DBConnect</code> also has another optional parameter - a handler that is called before creating a new session. You can place any custom logic there, for example:</p> <pre><code>async def renew_master_connect(connect: DBConnect): master_host = await get_master() # determine the master host if master_host != connect.host: # if the host has changed await connect.change_host(master_host) # reconnecting master = DBConnect( ... # handler before session creation before_create_session_handler=renew_master_connect, ) replica = DBConnect( ... before_create_session_handler=renew_replica_connect, ) </code></pre> <p>At the end of your application's lifecycle, you should gracefully close the connection. <code>DBConnect</code> provides a <code>close()</code> method for this purpose.</p> <pre><code>@asynccontextmanager async def lifespan(app): # some application startup logic yield # application termination logic await connection.close() # closing the connection to the database </code></pre> <p>All the important logic and \u201cmagic\u201d of session and transaction management is handled by the middleware - and it\u2019s very easy to set up.</p> <p>Here\u2019s an example for <strong>FastAPI</strong>:</p> <pre><code>from context_async_sqlalchemy.fastapi_utils import ( add_fastapi_http_db_session_middleware, ) app = FastAPI(...) add_fastapi_http_db_session_middleware(app) </code></pre> <p>There is also pure ASGI middleware.</p> <pre><code>from context_async_sqlalchemy import ASGIHTTPDBSessionMiddleware app.add_middleware(ASGIHTTPDBSessionMiddleware) </code></pre> <h1>Testing</h1> <p>Testing is a crucial part of development. I prefer to test using a real, live PostgreSQL database. In this case, there\u2019s one key issue that needs to be addressed - <strong>data isolation between tests</strong>. There are essentially two approaches:</p> <ul> <li><strong>Clearing data between tests.</strong> In this setup, the application uses its own transaction, and the test uses a separate one.</li> <li><strong>Using a shared transaction</strong> between the test and the application and performing rollbacks to restore the state.</li> </ul> <p>The first approach is very convenient for debugging, and sometimes it\u2019s the only practical option - for example, when testing complex scenarios involving multiple transactions or concurrent queries. It\u2019s also a <em>\u201cfair\u201d</em> testing method because it checks how the application actually handles sessions.</p> <p>However, it has a downside: such tests take longer to run because of the time required to clear data between them - even when using <code>TRUNCATE</code> statements, which still have to process all tables.</p> <p>The second approach, on the other hand, is much faster thanks to rollbacks, but it\u2019s not as realistic since we must prepare the session and transaction for the application in advance.</p> <p>In my projects, I use both approaches together: a shared transaction for most tests with simple logic, and separate transactions for the minority of more complex scenarios.</p> <p>The library provides a few utilities that make testing easier. The first is <code>rollback_session</code> - a session that is always rolled back at the end. It\u2019s useful for both types of tests and helps maintain a clean, isolated test environment.</p> <pre><code>@pytest_asyncio.fixture async def db_session_test(): async with rollback_session(master) as session: yield session </code></pre> <p>For tests that use shared transactions, the library provides two utilities: <code>set_test_context</code> and <code>put_savepoint_session_in_ctx</code>.</p> <pre><code>@pytest_asyncio.fixture(autouse=True) async def db_session_override(db_session_test): async with set_test_context(): async with put_savepoint_session_in_ctx(master, db_session_test): yield </code></pre> <p>This fixture creates a context in advance, so the application runs within it instead of creating its own. The context also contains a pre\u2011initialized session that creates a <strong>release savepoint</strong> instead of performing a commit.</p> <h1>How it all works</h1> <p>The middleware initializes the context, and your application accesses it through the library\u2019s functions. Finally, the middleware closes any remaining open resources and then cleans up the context itself.</p> <p>How the middleware works:</p> <p>The context we\u2019ve been talking about is a <code>ContextVar</code>. It stores a mutable container, and when your application accesses the library to obtain a session, the library operates on that container. Because the container is mutable, sessions and transactions can be closed early. The middleware then operates only on what remains open within the container.</p> <h1>Summary</h1> <p>Let\u2019s summarize. We\u2019ve built a great library that makes working with <strong>SQLAlchemy</strong> in asynchronous applications simple and enjoyable:</p> <ul> <li>Minimal code, no duplication</li> <li>Automatic commit or rollback - no need for manual management</li> <li>Full support for manual session and transaction control when needed</li> <li>Convenient for both CRUD operations and advanced use cases</li> <li>No new syntax - pure SQLAlchemy</li> <li>Framework\u2011agnostic</li> <li>Easy to test</li> </ul> <p><strong>Use it!</strong></p> <ul> <li>Licensed under the <strong>MIT License</strong></li> <li>Open\u2011source code on GitHub: <a href=\"https://github.com/krylosov-aa/context-async-sqlalchemy\">github.com/krylosov-aa/context-async-sqlalchemy</a></li> <li>Documentation: <a href=\"https://krylosov-aa.github.io/context-async-sqlalchemy/\">krylosov-aa.github.io/context-async-sqlalchemy</a></li> <li>Available on PyPI: <a href=\"https://pypi.org/project/context-async-sqlalchemy/\">pypi.org/project/context-async-sqlalchemy</a></li> </ul> <p>I\u2019m using this library in a real production environment - so feel free to use it in your own projects as well! Your feedback is always welcome - I\u2019m open to improvements, refinements, and suggestions.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/One-Novel1842\"> /u/One-Novel1842 </a> <br /> <span><a href=\"https://www.reddit.com/r/Python/comments/1pamid8/contextasyncsqlalchemy_the_best_way_to_use/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/Python/comments/1pamid8/contextasyncsqlalchemy_the_best_way_to_use/\">[comments]</a></span>",
      "author": "/u/One-Novel1842",
      "published_date": "2025-11-30T16:31:00+00:00",
      "source": "Reddit Python",
      "status": "processed",
      "priority": "medium",
      "tags": [],
      "word_count": 2286,
      "reading_time": 11,
      "created_at": "2025-11-30T19:16:07.845006+00:00",
      "updated_at": "2025-11-30T20:16:36.474535+00:00",
      "metadata": {
        "processed_at": "2025-11-30T20:16:36.474537+00:00",
        "processing_method": "github_actions"
      }
    },
    {
      "id": "cafeaea1ead6cf90a26beea8736b2b03",
      "url": "https://www.reddit.com/r/Python/comments/1paocj5/advanced_overlooked_python_typing/",
      "title": "Advanced, Overlooked Python Typing",
      "content": "<!-- SC_OFF --><div class=\"md\"><p>While quantitative research in software engineering is difficult to trust most of the time, some studies claim that type checking can reduce bugs by about 15% in Python. This post covers advanced typing features such as never types, type guards, concatenate, etc., that are often overlooked but can make a codebase more maintainable and easier to work with </p> <p><a href=\"https://martynassubonis.substack.com/p/advanced-overlooked-python-typing\">https://martynassubonis.substack.com/p/advanced-overlooked-python-typing</a></p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/Martynoas\"> /u/Martynoas </a> <br /> <span><a href=\"https://www.reddit.com/r/Python/comments/1paocj5/advanced_overlooked_python_typing/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/Python/comments/1paocj5/advanced_overlooked_python_typing/\">[comments]</a></span>",
      "author": "/u/Martynoas",
      "published_date": "2025-11-30T17:42:51+00:00",
      "source": "Reddit Python",
      "status": "processed",
      "priority": "medium",
      "tags": [],
      "word_count": 82,
      "reading_time": 1,
      "created_at": "2025-11-30T19:16:07.844591+00:00",
      "updated_at": "2025-11-30T20:16:36.474539+00:00",
      "metadata": {
        "processed_at": "2025-11-30T20:16:36.474540+00:00",
        "processing_method": "github_actions"
      }
    },
    {
      "id": "c112e55c41339e10b036259c74a57d54",
      "url": "https://humaninvariant.substack.com/p/notes-on-shadowing-a-hospitalist",
      "title": "Notes on Shadowing a Hospitalist",
      "content": "<p>Article URL: <a href=\"https://humaninvariant.substack.com/p/notes-on-shadowing-a-hospitalist\">https://humaninvariant.substack.com/p/notes-on-shadowing-a-hospitalist</a></p>\n<p>Comments URL: <a href=\"https://news.ycombinator.com/item?id=46098569\">https://news.ycombinator.com/item?id=46098569</a></p>\n<p>Points: 3</p>\n<p># Comments: 0</p>",
      "author": "surprisetalk",
      "published_date": "2025-11-30T17:25:40+00:00",
      "source": "Hacker News",
      "status": "processed",
      "priority": "medium",
      "tags": [],
      "word_count": 13,
      "reading_time": 1,
      "created_at": "2025-11-30T19:16:05.213255+00:00",
      "updated_at": "2025-11-30T20:16:36.474545+00:00",
      "metadata": {
        "processed_at": "2025-11-30T20:16:36.474547+00:00",
        "processing_method": "github_actions"
      }
    },
    {
      "id": "7435952e0834ce3bab69423a0615bac7",
      "url": "https://www.frontiersin.org/articles/10.3389/fnbot.2025.1691300",
      "title": "UHGAN: a dual-phase GAN with Hough-transform constraints for accurate farmland road extraction",
      "content": "IntroductionTraditional methods for farmland road extraction, such as U-Net, often struggle with complex noise and geometric features, leading to discontinuous extraction and insufficient sensitivity. To address these limitations, this study proposes a novel dual-phase generative adversarial network (GAN) named UHGAN, which integrates Hough-transform constraints.MethodsWe designed a cascaded U-Net generator within a two-stage GAN framework. The Stage 1 GAN combines a differentiable Hough transform loss with cross-entropy loss to generate initial road masks. Subsequently, the Stage 2 U-Net refines these masks by repairing breakpoints and suppressing isolated noise.ResultsWhen evaluated on the WHU RuR+rural road dataset, the proposed UHGAN method achieved an accuracy of 0.826, a recall of 0.750, and an F1-score of 0.789. This represents a significant improvement over the single-stage U-Net (F1\u202f=\u202f0.756) and ResNet (F1\u202f=\u202f0.762) baselines.DiscussionThe results demonstrate that our approach effectively mitigates the issues of discontinuous extraction caused by the complex geometric shapes and partial occlusion characteristic of farmland roads. The integration of Hough-transform loss, an technique that has received limited attention in prior studies, proves to be highly beneficial. This method shows considerable promise for practical applications in rural infrastructure planning and precision agriculture.",
      "author": "Yuan Ma",
      "published_date": "2025-10-13T00:00:00+00:00",
      "source": "Frontiers Neurorobotics",
      "status": "pending",
      "priority": "medium",
      "tags": [],
      "word_count": 190,
      "reading_time": 1,
      "created_at": "2025-11-30T18:49:48.302533+00:00",
      "updated_at": "2025-11-30T18:49:48.302535+00:00"
    }
  ]
}